// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package action

import (
	"context"

	"github.com/raohwork/task"
)

// Converter is a function to convert one type of data into another.
//
// It is designed to interact with the value generated by [Data] to create a new
// value. In other words, it creates a new [Data] from one [Data]. It is suggested
// to name it using short phrase to describe what new data is, like "response", to
// write code like this:
//
//	Get(response).From(request)
//
// which means creates a response by do something to request and returns any error.
type Converter[I, O any] func(context.Context, I) (O, error)

// Get creates a Converter, mostly for type converting.
func Get[I, O any](f func(context.Context, I) (O, error)) Converter[I, O] { return f }

// NoCtxGet creates Converter from f by ignoring context.
func NoCtxGet[I, O any](f func(I) (O, error)) Converter[I, O] {
	return func(_ context.Context, i I) (O, error) {
		return f(i)
	}
}

// NoErrGet creates Converter from f by ignoring context and error.
func NoErrGet[I, O any](f func(I) O) Converter[I, O] {
	return func(_ context.Context, i I) (O, error) {
		return f(i), nil
	}
}

// Then creates a new Converter by chaining two converters.
//
// Type of next is limited to O -> O by language design.
func (c Converter[I, O]) Then(next Converter[O, O]) Converter[I, O] {
	return func(ctx context.Context, i I) (ret O, err error) {
		ret, err = c(ctx, i)
		if err != nil {
			return
		}
		return next(ctx, ret)
	}
}

// From creates a [Data] of output type by feeding i to the converter.
func (c Converter[I, O]) From(i Data[I]) Data[O] {
	return func(ctx context.Context) (ret O, err error) {
		input, err := i(ctx)
		if err != nil {
			return
		}
		return c(ctx, input)
	}
}

// By is like From but uses raw value instead of [Data].
func (c Converter[I, O]) By(i I) Data[O] {
	return func(ctx context.Context) (ret O, err error) { return c(ctx, i) }
}

// With wraps c to modify the context before run it.
func (c Converter[I, O]) With(mod task.CtxMod) Converter[I, O] {
	return func(ctx context.Context, i I) (ret O, err error) {
		ctx, cancel := mod(ctx)
		defer cancel()
		return c(ctx, i)
	}
}

// Pre wraps c to run f before it.
func (c Converter[I, O]) Pre(f func(I)) Converter[I, O] {
	return func(ctx context.Context, i I) (ret O, err error) {
		f(i)
		return c(ctx, i)
	}
}

// Post wraps c to run f after it.
func (c Converter[I, O]) Post(f func(I, O, error)) Converter[I, O] {
	return func(ctx context.Context, i I) (ret O, err error) {
		ret, err = c(ctx, i)
		f(i, ret, err)
		return
	}
}

// Defer wraps c to run f after it.
func (c Converter[I, O]) Defer(f func()) Converter[I, O] {
	return func(ctx context.Context, i I) (ret O, err error) {
		ret, err = c(ctx, i)
		f()
		return
	}
}

// Join creates a new Converter by joining two converters.
//
// It's impossible to implement something like Join(i, j, k, ...) because of
// language design.
func Join[A, B, C any](i Converter[A, B], j Converter[B, C]) Converter[A, C] {
	return func(ctx context.Context, a A) (ret C, err error) {
		b, err := i(ctx, a)
		if err != nil {
			return
		}
		return j(ctx, b)
	}
}
